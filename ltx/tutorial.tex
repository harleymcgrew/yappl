YAPPL was designed to make working with probabilities as easy as possible. The following tutorial will guide you through the language and eventually define a geometric distribution and use it for simple queries. 

\subsection{Basic variables}

Let's begin by exploring the simple concepts of the language. There are three basic data types: integers, floating-point numbers, and booleans. Here's how to declare variables as each one of these:

\begin{verbatim}
int:num
float:number_with_a_dot
bool:truthful
\end{verbatim}

It would be helpful if we could give these variables values and actually use them. To do so, we need to discuss scope. When a variable is bound to a value, you must also specify where it is defined. This is done explicitly through the \texttt{let\dots in} operation:

\begin{verbatim}
let int:num = 5 in
  num + 5
\end{verbatim}

The scope of \texttt{num} is the block after \texttt{in}.

\subsection{Functions}

Function declaration and definition looks similar to its variable counterparts. Scoping works the same way, where a function's scope begins immediately after the \texttt{in} keyword. 

\begin{verbatim}
fun int:add int:a int:b = 
   a + b
in 
  add 1 2
\end{verbatim}

\begin{verbatim}
fun float:geom float:q = 
\end{verbatim}



%# single line comment
%### multi
%    line
%	comment
%###
%
%# value definition
%float:q = .9;
%# q is defined as 0.9 in the global scope
%
%# sample binding;
%int:x = ~geom q | @ > 5;
%# x is bound to the return value of the function geom evaluated with
%# parameter q; the Ò| @ > 5Ó means that the return value of ~geom q is 
%# conditions being greater than 5
%
%# function definition
%int:oneOrTwo float:q = geom q | @ = 1 or @ = 2;
%# a function that samples from geom q, conditional on the sample being 1 or 2
%
%# function equivalent to above
%fun int:oneOrTwo2 int:q =
%   int:x = ~geom q in
%   if x = 1 or x = 2 then
%x
%   else
%~oneOrTwo2 q;
%
%fun bool gtFive int:x = x > 5;
%
%# this is a memoized function
%fun int:f int:n := ~geom .9 | gtFive @;
%~f 0;
%-> 16
%~f 1;
%-> 6
%# later, ~f 0 still returns 16
%~f 0;
%-> 16 
%
%fun int[]:apply (fun int int):f int[]:a =
%	match(a) with
%case x :: rest -> ~f x :: ~apply f rest
%		case [] 	   -> ();
%# apply has type fun int[] ((fun int int) int[])
%# f has type fun int (int)