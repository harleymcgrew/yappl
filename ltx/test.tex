\subsection{Example Programs}
The Dirichlet process (DP) is a stochastic process. Draws from a DP are discrete distributions with some other distribution as their ``mean'' distribution. In the example below, we create a draw from a DP with a geometric distribution as its mean. We are then able to take samples from this distribution. We use the ``stick breaking'' representation of the Dirichlet process. Memoization is used to keep track of the weights on the atoms in the draw from the DP. A distribution drawn from a DP has a ``rich-get-richer'' property. So when the code below is run, you will see that numbers that appear early in the sequence tend to reappear. 

\lstyappllisting{tutorials/dpmem.ypl}
\lstinputlisting[title=tutorials/dpmem.ml, language={[Objective]Caml}]{../yappl/tutorials/dpmem.ml}

\lstyappllisting{tutorials/fib.ypl}
\lstinputlisting[title=tutorials/fib.ml, language={[Objective]Caml}]{../yappl/tutorials/fib.ml}

\subsection{Test Suites}
Our testing strategy was ``bottom-up'': we began by writing tests for the simplest functionality possible, namely printing an integer literal. We increased the complexity of our tests as more of the grammar was implemented. We tried to ensure that each language feature--such as data types, functions, pattern matching, and memoization--was covered by at least one test. Testing the builtin \texttt{rand}, however, can only be done manually, as random numbers have no guarantees. As bugs were found, regression tests for those bugs were written so they would not crop up again. Once most of the language was indeed implemented, we wrote slightly more involved tests, such as creating toy functions.\\
The testing script was based on the MICROC test suite's \texttt{testall.sh} script provided to the class. Our tests work rather simply; the printed output is compared to the expected output file's contents.\\
Additional ``testing'' was performed via writing and running several examples programs for the tutorial (Section 2) and test plan (Section 6.1). We also added several tests for errors; we expect each error example to fail to compile, and check if an error was produced. This is important so that we know if the grammar is too inclusive.