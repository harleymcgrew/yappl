This is our language reference manual. 

\subsection{Lexical conventions}

As our syntax is inspired by OCaml, many of our lexical conventions follow those of that language. YAPPL has four kinds of tokens: identifiers, keywords, constants, and expression operators. Whitespace such as blanks, tabs, and newlines are ignored and serve to separate tokens. Comments are also ignored.

\subsubsection{Comments}

A single \texttt{\#} indicates that all succeeding characters shall be considered part of a comment and ignored until a newline is encountered. \\
\\
Immediately following a newline, a series of three \texttt{\#\#\#} indicates that all succeeding characters shall be considered part of a comment until another series of three \texttt{\#\#\#} is encountered. Note that newlines are ignored following the \texttt{\#\#\#}, which essentially delimits multi-line comments.

\subsubsection{Identifiers}

An identifier is a series of alphabetical letters and digits; the first character must be alphabetic. 

\subsubsection{Keywords}

The following identifiers are reserved as keywords and may not be used otherwise:
\begin{table}[htdp]
\center
\begin{tabular}{c c c}
\texttt{fun} & \texttt{if} &\texttt{match} \\
\texttt{int} & \texttt{then} & \texttt{with} \\
\texttt{bool} & \texttt{else} &\texttt{case} \\
\texttt{float} & \texttt{in} & \texttt{string} \\
\texttt{true} & \texttt{false} & \texttt{print} \\
\end{tabular}
\label{default}
\end{table}%



\subsubsection{Constants}

YAPPL only supports numeric constants (integers and floats).

\subsection{Types}

The following are the data types in YAPPL:\\
\begin{tabular}{l l}
\texttt{int} & an integer.\\
\texttt{float} & double-precision floating point.\\
\texttt{bool} & a boolean value (either \texttt{true} or \texttt{false}).\\
\texttt{int[]} & a list of integers.\\
\texttt{float[]} & a list of floating points.\\
\texttt{bool[]} & a list of booleans.
\end{tabular}\\\\
YAPPL does not support conversion between types. All types are immutable.

\subsubsection{Constants}
Integer constants, e.g. \texttt{1337}, are of type \texttt{int}.\\\\
Floating-point constants, e.g. \texttt{9000.1} or \texttt{2e-5} or \texttt{1.4e9}, are of type \texttt{float}.\\\\
The reserved boolean constants are \texttt{true} and \texttt{false}.

\subsubsection{Declarations}
All variables must either be declared in a function header or declared when initialized. A declaration specifies a type and a name. The format is \texttt{type:name}.\\\\
\texttt{fun int:add2(int:a) = a + 2;}\\
\texttt{int:temp = 2;}\\
\texttt{float[]:data = [1.0 2e-2 -0.75];}\\
\texttt{bool:flag = false;}


\subsection{Operations}

\subsubsection{Value definitions (\texttt{=})}
\texttt{float:q = .9;}\\
\\
This assigns a value to a variable. Once assigned, the value is constant and cannot be reassigned.

\subsubsection{Sampling (\texttt{\midtilde})}
\texttt{\midtilde bin;}\\
\\
This samples \texttt{bin} and returns the value.

\subsubsection{Binding (\texttt{= \midtilde })}
\texttt{int:x = \midtilde geom q;}\\
\\
This binds a variable to a function's return value. In this case, \texttt{x} is bound to the return value of the function \texttt{geom} evaluated with parameter \texttt{q}.

\subsubsection{Function definition (\texttt{=})}
\texttt{fun int:oneOrTwo float:q = geom q;}\\
\\
This defines a function \texttt{oneOrTwo} that samples from \texttt{geom q}. It has a return type of \texttt{int} and takes a single parameter \texttt{q} of type \texttt{float}. 

\subsubsection{Conditioning (\texttt{|})}
\texttt{fun int:oneOrTwo float:q = geom q | @ = 1 or @ = 2;}\\
\\
This is identical to the previous \texttt{oneOrTwo} except we now condition that the sample be 1 or 2.

\subsubsection{Memoized function definition (\texttt{:=})}
\texttt{fun int:f int:n := ~geom .9;}\\
\\
\texttt{f} is a memoized function that returns the same value for each sample.

\subsection{Expressions}
(Harley)

The precedence of expression operators is the same order as they are presented below. Operators in the same grouping (multiplicative, additive, relational etc.) are given the same precedence. Expressions on either side of binary operations must have the same type. 

\subsubsection{Primary expressions}
Primary expressions such as $\sim$ involving function calls group left to right

\paragraph{\textit{identifier}}
An identifier is a primary expression, provided it has been suitably bound. Its type is specified when bound. 

\paragraph{\textit{constant}}
A decimal or floating constant is a primary expression. Its type is \texttt{int} in the first case, \texttt{float} in the last. 

\paragraph{\textit{list-identifier}[\textit{integer-expression}]}
An identifier followed by an expression in square brackets is a primary expression that yields the value at the \texttt{int}  index of a list.

\paragraph{(\textit{expression})}
A parenthesized expression is a primary expression whose type and value are identical to those of the unadorned expression. 



\subsubsection{Unary operators}
Expressions with unary operators group right-to-left.

\paragraph{! \textit{expression}}
The logical negation ! operator yields true if the value of the expression is false, and false if the value of the expression is true. 

\subsubsection{Multiplicative operators}
The multiplicative operators *, /, and \% group left-to-right.

\paragraph{\textit{expression} * \textit{expression}}
The binary * operator indicates multiplication and groups left-to-right.

\paragraph{\textit{expression} / \textit{expression}}
The binary / operator indicates division and groups left-to-right 

\paragraph{\textit{expression} \% \textit{expression}}
The  binary \% operator results in the remainder from the division of the first expression by the second and groups left-to-right. Both operands must be type \texttt{int} and the result is \texttt{int}. The remainder has the same sign as the dividend.
\\
\subsubsection{Additive operators}
The additive operators $+$ and $-$ group left-to-right.

\paragraph{\textit{expression} + \textit{expression}}
The binary  operator + indicates the sum of the expressions, and groups left-to-right.

\paragraph{\textit{expression} $-$ \textit{expression}}
The binary  operator $-$ indicates the difference of the operands, and groups left-to-right.
\\
\subsubsection{Relational operators}
The  relational operators < (less than), > (greater than), <= (less than or equal to) and >= (greater than or equal to) all yield false if the specified relation is false, and true if it is true. These operators group left-to-right. However, this is not particularly meaningful. For example, in a<b<c, a<b will evaluate to either true or false, and then the resulting expression is type mismatched or meaningless.

\paragraph{\textit{expression} < \textit{expression}}
\paragraph{\textit{expression} > \textit{expression}}
\paragraph{\textit{expression} <= \textit{expression}}
\paragraph{\textit{expression} >= \textit{expression}}


\subsubsection{Equality operators}
The \texttt{=} (equal to) and the \texttt{!=} (not equal to) operators function as the relational operators above, but have a lower precedence. Therefore, "a<b = c<d" is true when a<b and c<d have the same truth value.
\\
\paragraph{\textit{expression} = \textit{expression}}
\paragraph{\textit{expression} != \textit{expression}}

\subsubsection{Assignment operators}
\paragraph{\textit{identifier} = \textit{expression}}
The value of the expression is bound to the identifier.

\subsubsection{\textit{expression} or \textit{expression}}
The \texttt{or} operator returns true if either of its operands are false and false otherwise; \texttt{or} groups left-to-right, and the second operand may not be evaluated if the value of the first is false.

\subsubsection{\textit{expression} | \textit{expression}}
The predicate operator \texttt{|} requires the re-evaluation of the expression on the left until the conditional expression on the right evaluates to true. This will loop forever if the expression on the left can never satisfy the conditional.

\subsubsection{\textit{expression} @ \textit{expression}} 
The concatenation operator yields an list that is the concatenation of the left list at the head of the right list. Both sides must be lists of matching type (i.e. \texttt{fun[], int[], bool[], float[]}.) 

\subsubsection{\textit{expression} ; \textit{expression}}
A pair of expressions separated by a semicolon is evaluated left-to-right and the value of the left expression is discarded. The type and value of the result are the type and value of the right operand. This operator groups left to right. 
 
\subsection{Functions}

(Jonathan)

\subsection{Grammar}

(Everyone)

\begin{alltt}\normalfont\emph{
identifier:
\quad identifier-chars \tn{but not a reserved word}

identifier-chars:
\quad letter
\quad identifier-chars alpha-num

constant: 
\quad literal
\quad \tn{[]}

literal:
\quad integer-literal
\quad float-literal
\quad bool-literal

int-literal:

float-literal:

bool-literal: one of
\quad \tn{true false}

type:
\quad basic-type
\quad array-type

array-type:
\quad basic-type\tn{[]}

basic-type: one of
\quad \tn{int float bool}

pattern:

statement:

expression:
\quad constant
\quad \tn( expression \textnormal)
\quad expression \textnormal{;} expression
\quad expression \textnormal{::} expression
\quad \tn[ expression \textnormal{,} expression \tn]
\quad \tn{if} expression \tn{then} expression \tn{else} expression
\quad \tn{if} expression \tn{then} expression 
\quad \tn{match} expression \tn{with} pattern-matching
\quad identifier

assignment-op: \tn{
\quad = 
\quad :=  }

infix-op:

function-decl:

var-decl:
\quad type \tn{:} identifier

declarator:

letter: one of
\quad \tn{a ... z A ... Z}

digit: one of
\quad \tn{0 ... 9}

alpha-num:
\quad letter
\quad digit
}\end{alltt}


