This is our language reference manual. 

\subsection{Lexical conventions}

As our syntax is inspired by OCaml, many of our lexical conventions follow those of that language. YAPPL has four kinds of tokens: identifiers, keywords, constants, and expression operators. Whitespace such as blanks, tabs, and newlines are ignored and serve to separate tokens. Comments are also ignored.

\subsubsection{Comments}

A single \texttt{\#} indicates that all succeeding characters shall be considered part of a comment and ignored until a newline is encountered. \\
\\
Immediately following a newline, a series of three \texttt{\#\#\#} indicates that all succeeding characters shall be considered part of a comment until another series of three \texttt{\#\#\#} is encountered. Note that newlines are ignored following the \texttt{\#\#\#}, which essentially delimits multi-line comments.

\subsubsection{Identifiers}

An identifier is a series of alphabetical letters and digits; the first character must be alphabetic. 

\subsubsection{Keywords}

The following identifiers are reserved as keywords and may not be used otherwise:
\begin{table}[htdp]
\center
\begin{tabular}{c c c}
\texttt{fun} & \texttt{if} &\texttt{match} \\
\texttt{int} & \texttt{then} & \texttt{with} \\
\texttt{bool} & \texttt{else} &\texttt{case} \\
\texttt{float} & \texttt{in} & \texttt{string} \\
\texttt{true} & \texttt{false} \\
\end{tabular}
\label{default}
\end{table}%



\subsubsection{Constants}

YAPPL only supports numeric constants (integers and floats).

\subsection{Types}

(Hans)

\subsection{Operations}

\subsubsection{Value definitions (\texttt{=})}
\texttt{float:q = .9;}\\
\\
This assigns a value to a variable. 

\subsubsection{Sampling (\texttt{\textasciitilde})}
\texttt{\textasciitilde bin;}\\
\\
This samples \texttt{bin} and returns the value.

\subsubsection{Binding (\texttt{= \textasciitilde })}
\texttt{int:x = \textasciitilde geom q;}\\
\\
This binds a variable to a function's return value. In this case, \texttt{x} is bound to the return value of the function \texttt{geom} evaluated with parameter \texttt{q}.

\subsubsection{Function definition (\texttt{=})}
\texttt{fun int:oneOrTwo float:q = geom q;}\\
\\
This defines a function \texttt{oneOrTwo} that samples from \texttt{geom q}. It has a return type of \texttt{int} and takes a single parameter \texttt{q} of type \texttt{float}. 

\subsubsection{Conditioning (\texttt{|})}
\texttt{fun int:oneOrTwo float:q = geom q | @ = 1 or @ = 2;}\\
\\
This is identical to the previous \texttt{oneOrTwo} except we now condition that the sample be 1 or 2.

\subsubsection{Memoized function definition (\texttt{:=})}
\texttt{fun int:f int:n := ~geom .9;}\\
\\
\texttt{f} is a memoized function that returns the same value for each sample.

\subsection{Expressions}

(Harley)


\subsubsection{\textit{expression * expression}}
The binary * operator indicates multiplication and groups left-to-right.
\\
\subsubsection{\textit{expression / expression}}
The binary / operator indicates division and groups left-to-right 
\\
\subsubsection{\textit{expression \% expression}}
The binary \% results in the remainder from the division of the first expression by the second and groups left-to-right. Both operands must be type \texttt{int} and the result is \texttt{int}. The remainder has the same sign as the dividend.
\\
\subsubsection{\textit{expression + expression}}
The binary additive operator + indicates the sum of the expressions, and groups left-to-right.
\\
\subsection{\textit{expression - expression}}
The binary additive operator - indicates the difference of the operands, and groups left-to-right.

\subsection{\textit{expression < expression}}
\subsection{\textit{expression > expression}}
\subsection{\textit{expression <= expression}}
\subsection{\textit{expression >= expression}}
The relational operators < (less than), > (greater than), <= (less than or equal to) and >= (greater than or equal to) all yield 0 if the specified relation is false, and 1 if it is true. These operators group left-to-right, however: note, in the case of a<b<c, a<b will first be evaluated to 1 or 0. Therefore a<b<c does not mean the same thing as a<b and b<c.

\subsection{\textit{expression = expression}}
\subsection{\textit{expression != expression}}
The \texttt{=} (equal to) and the \texttt{!=} (not equal to) operators function as the relational operators above, but have a lower precedence. Therefore, "a<b =c<d" is 1 when a<b and c<d have the same truth value. 

\subsection{\textit{expression or expression}}

\subsection{Functions}

(Jonathan)

\subsection{Grammar}

(Everyone)

\begin{alltt}\normalfont\emph{
Identifier:
\quad IdentifierChars \textnormal{but not a reserved word}

IdentifierChars:
\quad Letter
\quad IndentifierChars AlphaNum

Literal:
\quad IntegerLiteral
\quad FloatingPointLiteral
\quad BooleanLiteral

BooleanLiteral: one of
\quad \textnormal{true false}

Type: one of
\quad \textnormal{int float boolean}

Statement:

Expression:

AssignmentOperator: \textnormal {
\quad = 
\quad := 
\quad \(\sim\)= }

InfixOp:

FunctionDecl:

Declarator:

Letter: one of
\quad \textnormal{a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}

Digit: one of
\quad \textnormal{0 1 2 3 4 5 6 7 8 9}

AlphaNum:
\quad Letter
\quad Digit
}\end{alltt}


